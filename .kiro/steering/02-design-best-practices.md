---
inclusion: manual
---

# 方案设计阶段最佳实践

## 阶段目标

将需求转化为清晰、可执行的技术设计方案，为任务拆分和实现奠定基础。

## 为什么设计阶段如此重要

设计是连接需求和实现的桥梁。好的设计可以：
- 降低实现阶段的技术风险
- 提供清晰的开发指导
- 确保架构决策的一致性
- 支持团队协作和知识共享

**关键原则**：设计必须既满足需求，又具备可实施性。

## 设计工作流程

### 第一步：理解和分析需求

在开始设计前，充分理解需求文档。

**关键活动**：
- 通读需求文档，理解业务目标
- 识别核心功能和非功能性需求
- 标记需要技术调研的领域
- 列出需要澄清的问题

### 第二步：技术调研和选型

基于需求特点，进行必要的技术调研。

**调研内容**：
- 技术栈选择（语言、框架、库）
- 架构模式选择（分层、微服务、事件驱动等）
- 第三方服务和工具选择
- 性能和可扩展性方案

**选型原则**：
- 基于需求特点选择合适的技术
- 考虑团队技术能力和学习成本
- 评估技术方案的可行性和风险
- 权衡成本、性能、可维护性

### 第三步：创建设计文档

将调研结果和设计思路整理成结构化的设计文档。

**设计文档应包含**：

#### 1. 概述
- 项目背景和目标
- 设计范围和边界
- 关键约束和假设

#### 2. 架构设计
- 系统架构图（展示主要组件和交互关系）
- 模块划分（明确各模块的职责边界）
- 技术栈选择（列出关键技术及选择理由）
- 部署架构（如适用）

#### 3. 详细设计
- 核心模块设计
- 接口定义（API 规范、输入输出格式）
- 数据模型（核心数据结构、数据库设计）
- 关键流程和算法

#### 4. 非功能性设计
- 性能设计（响应时间、吞吐量等指标）
- 安全设计（身份认证、授权、数据保护）
- 可观测性设计（日志、监控、链路追踪）
- 错误处理和容错机制

#### 5. 技术决策记录（ADR）
- 记录重要的架构决策
- 说明决策背景、理由和影响

#### 6. 风险和应对
- 识别潜在的技术风险
- 制定应对策略和备选方案

### 第四步：设计验证

**关键**：设计完成后，不要立即进入任务拆分，而是进行充分的验证。

**验证维度**：

#### 1. 与需求的一致性
- [ ] 设计是否完全覆盖了所有需求？
- [ ] 是否有需求未被设计覆盖？
- [ ] 设计是否准确理解了需求意图？

#### 2. 设计内部的一致性
- [ ] 设计内容内部是否有冲突？
- [ ] 模块之间的接口定义是否清晰？
- [ ] 数据流和控制流是否合理？
- [ ] 技术选型之间是否兼容？

#### 3. 设计的合理性
- [ ] 是否存在过度设计的内容？
- [ ] 技术选型是否合理？
- [ ] 是否考虑了可扩展性和可维护性？
- [ ] 是否符合项目约束（时间、成本、资源）？

#### 4. 设计的可实施性
- [ ] 设计是否可以被实现？
- [ ] 技术方案是否经过验证？
- [ ] 是否识别了关键的技术难点？
- [ ] 是否有明确的实现路径？

**验证方法**：

使用以下提示词让 Kiro 进行自检：

> "请再次检查设计文档与需求文档是一致的，并且设计自身的内容内部没有冲突，且能完全并准确的覆盖需求。"

> "请检查设计中，是否有需求未提及的内容，属于过度设计的内容？如果有，请与我确认，是否补充和完善需求。"

### 第五步：用户确认

与用户确认设计方案，确保理解一致。

**必须确认的内容**：
- 架构方案是否符合预期
- 技术选型是否可接受
- 是否有遗漏的重要设计点
- 是否需要调整需求或设计

**只有在用户明确确认后，才能进入任务拆分阶段。**

## 架构决策记录（ADR）

### 什么是 ADR

ADR（Architecture Decision Record）是架构决策记录，用于记录重要的架构决策及其背景、理由和影响。

### 为什么需要 ADR

- 记录决策的上下文和理由，避免信息丢失
- 帮助团队理解为什么做出某些技术选择
- 为未来的架构演进提供参考
- 避免重复讨论已经决定的问题
- 便于新成员快速了解项目历史

### ADR 的基本结构

每个 ADR 应包含以下内容：

1. **标题**：简短描述决策内容
2. **状态**：提议中、已接受、已废弃、已替代等
3. **背景**：为什么需要做这个决策？面临什么问题？
4. **决策**：具体的决策内容是什么？
5. **理由**：为什么选择这个方案？考虑了哪些因素？
6. **后果**：这个决策带来的影响（正面和负面）

### ADR 示例

**ADR-001：选择关系型数据库而非 NoSQL**

- **状态**：已接受
- **背景**：需要选择数据存储方案，数据具有复杂的关系和事务要求
- **决策**：选择关系型数据库（PostgreSQL）作为主数据存储
- **理由**：
  - 数据具有明确的关系结构
  - 需要 ACID 事务保证
  - 需要复杂查询和聚合能力
  - 团队熟悉 SQL
- **后果**：
  - 正面：数据一致性强，查询能力强，生态成熟
  - 负面：水平扩展相对困难，需要考虑分库分表

**ADR-002：选择分层架构而非微服务**

- **状态**：已接受
- **背景**：需要确定系统架构模式，团队规模较小，业务复杂度中等
- **决策**：采用分层架构（单体应用）
- **理由**：
  - 团队规模小，不需要独立部署
  - 业务复杂度可控
  - 降低运维复杂度
  - 开发和调试更简单
- **后果**：
  - 正面：开发效率高，运维简单，易于调试
  - 负面：未来扩展需要重构，模块边界需要严格控制

### 在设计阶段使用 ADR

对于重要的技术选型和架构决策，应该：

1. **识别决策点**：哪些是关键的架构决策？
2. **创建 ADR**：记录决策的背景、理由和影响
3. **团队讨论**：与团队或用户讨论并达成共识
4. **纳入设计文档**：将 ADR 作为设计文档的一部分
5. **持续维护**：决策变更时更新 ADR 状态

### ADR 最佳实践

- 只记录重要的架构决策（不是所有决策都需要 ADR）
- 保持 ADR 简洁明了（1-2 页即可）
- 及时记录（决策做出时就记录，不要事后补）
- 及时更新状态（决策变更时更新）
- 将 ADR 纳入版本控制（与代码一起管理）
- 定期回顾 ADR（检查决策是否仍然有效）

## 常见问题与应对

### 问题 1：设计过于抽象

**表现**：设计文档只有高层架构图，缺乏具体的模块设计和接口定义。

**应对**：
- 为每个核心模块提供详细设计
- 定义清晰的接口和数据结构
- 提供关键流程的序列图或流程图
- 说明模块间的交互方式

### 问题 2：设计包含过多实现细节

**表现**：设计文档中包含具体的代码实现、配置细节等。

**应对**：
- 设计应该描述"做什么"和"为什么"，而非"怎么做"
- 将实现细节留给任务拆分和编码阶段
- 关注架构、模块划分、接口定义
- 保持适当的抽象层次

### 问题 3：过度设计

**表现**：设计了很多当前不需要的功能和扩展点。

**应对**：
- 只设计满足当前需求的功能
- 预留扩展点，但不提前实现
- 遵循 YAGNI 原则（You Aren't Gonna Need It）
- 与用户确认是否需要补充需求

### 问题 4：技术选型缺乏依据

**表现**：选择了某个技术，但没有说明为什么选择它。

**应对**：
- 使用 ADR 记录技术选型决策
- 说明选择的理由和权衡
- 考虑团队能力、项目约束、技术成熟度
- 评估风险和备选方案

## 检查清单

在进入任务拆分阶段前，确认以下所有项：

- [ ] 已充分理解需求文档
- [ ] 已完成必要的技术调研
- [ ] 已创建完整的设计文档（概述、架构、详细设计、非功能性设计）
- [ ] 已记录重要的技术决策（ADR）
- [ ] 已进行设计验证（一致性、合理性、可实施性）
- [ ] 设计完全覆盖了所有需求
- [ ] 设计内部没有冲突和矛盾
- [ ] 已识别潜在风险并制定应对策略
- [ ] 已与用户确认设计方案
- [ ] 已获得用户对设计文档的明确认可

## 关键收益

遵循设计阶段最佳实践，可以：

- ✅ 及早发现设计缺陷，降低实现风险
- ✅ 确保设计可实施性，提供清晰的开发指导
- ✅ 避免过度设计，保持适当的复杂度
- ✅ 提高开发效率，减少返工
- ✅ 降低技术债务，提升可维护性
- ✅ 记录重要决策，便于未来维护和演进

**记住**：设计阶段多花 2 小时，可以节省实现阶段的 20 小时。
