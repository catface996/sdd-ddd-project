---
inclusion: always
---

# 任务拆分阶段最佳实践

## 阶段目标

将设计方案拆分为可独立执行、可验证的具体任务，确保每个任务都有明确的目标和验收标准。

## 为什么任务拆分如此重要

任务拆分是将设计转化为可执行步骤的关键环节。好的任务拆分可以：
- 提高开发效率和质量
- 降低任务间的耦合度
- 支持并行开发和增量交付
- 便于进度跟踪和风险控制
- 确保交付物的可验证性

**关键原则**：任务必须既可执行又可验证。

## 任务拆分工作流程

### 第一步：理解设计方案

在开始拆分任务前，充分理解设计文档。

**关键活动**：
- 通读设计文档，理解架构和模块划分
- 识别核心功能和依赖关系
- 标记技术难点和风险点
- 列出需要澄清的问题

### 第二步：创建任务列表

基于设计文档，将设计转化为可执行的任务列表。

**任务拆分原则**：

#### 1. 单一职责
每个任务只关注一个明确的目标，避免任务过于复杂。

**为什么重要**：
- 降低任务复杂度，易于理解和执行
- 便于独立验证和测试
- 减少任务间的耦合

#### 2. 可独立验证
每个任务完成后应该能够独立验证其正确性。

**为什么重要**：
- 及早发现问题，降低修复成本
- 确保每个任务的质量
- 支持增量交付

#### 3. 合理的依赖关系
任务之间的依赖应该清晰明确，避免循环依赖。

**为什么重要**：
- 明确任务执行顺序
- 支持并行开发
- 便于进度管理

#### 4. 增量交付
任务应该支持增量开发，每完成一个任务都应该让项目向前推进一步。

**为什么重要**：
- 持续产生价值
- 及早获得反馈
- 降低集成风险

### 第三步：编写任务描述

为每个任务编写清晰的描述和验收标准。

**任务描述应包含**：

#### 1. 任务目标
要实现什么功能或完成什么工作（描述"做什么"，而非"怎么做"）

#### 2. 前置条件
任务开始前需要满足的条件（依赖哪些其他任务）

#### 3. 输出产物
任务完成后应该产生什么（代码、配置、文档等）

#### 4. 验收标准
如何验证任务是否正确完成（具体、可执行、可测试）

### 第四步：任务列表验证

**关键**：任务列表创建完成后，不要立即开始执行，而是进行充分的验证。

**验证维度**：

#### 1. 与需求和设计的一致性
- [ ] 任务列表是否与需求和设计一致？
- [ ] 是否有超出设计范围的任务？
- [ ] 是否完整覆盖了设计中的所有内容？
- [ ] 是否有遗漏的功能或模块？

#### 2. 任务的可执行性
- [ ] 每个任务的目标是否明确？
- [ ] 任务的粒度是否合适（1-4 小时）？
- [ ] 任务之间的依赖关系是否清晰？
- [ ] 是否有循环依赖？

#### 3. 任务的可验证性
- [ ] 每个任务的验证标准是否明确？
- [ ] 验证标准是否具体、可执行？
- [ ] 验证方法是否可操作？
- [ ] 是否明确了验证优先级（运行时 > 构建 > 静态）？

**验证方法**：

使用以下提示词让 Kiro 进行自检：

> "请检查任务列表是否与需求和设计一致，是否有超出设计范围的任务。另外，请明确每个任务的验证标准，并对任务进行验证。"

### 第五步：用户确认

与用户确认任务列表，确保理解一致。

**必须确认的内容**：
- 任务拆分的粒度是否合适
- 任务优先级和顺序是否合理
- 是否有遗漏或不必要的任务
- 验收标准是否清晰可行

**只有在用户明确确认后，才能开始执行任务。**

## 验收原则

任务验收应遵循以下优先级顺序：

### 1. 运行时验证（最优先）
能通过实际运行应用来验证的功能，必须通过运行应用进行验证。

**适用场景**：
- 配置验证（多环境、特性开关等）
- API 端点功能验证
- 日志输出格式验证
- 异常处理验证
- 集成功能验证
- 外部服务连接验证

**验证方法**：
- 启动应用（使用项目的启动命令）
- 访问相关端点或触发相关功能
- 检查实际运行结果是否符合预期

### 2. 构建验证（次优先）
无法通过运行验证的结构性要求，通过构建项目进行验证。

**适用场景**：
- 模块/组件结构验证
- 依赖关系验证
- 构建配置验证
- 代码语法正确性验证

**验证方法**：
- 执行项目的构建命令确保构建成功
- 检查构建日志中的组件顺序和依赖关系
- 确认构建产物符合预期

### 3. 静态检查（最后）
仅在无法通过上述两种方式验证时，才使用静态文件检查。

**适用场景**：
- 文件存在性检查
- 配置文件内容检查
- 目录结构检查

**验证方法**：
- 检查文件是否存在
- 检查文件内容是否符合要求

## 任务描述的三个层次

**核心原则**：任务描述应该是"做什么"，而不是"怎么做"

任务拆分的目标是将设计转化为可执行的目标，而不是编写详细的编码指令。任务应该描述要达成的结果，而不是逐步的实现细节。

### 1. 目标层（推荐）

**特点**：描述要达成的结果，不涉及具体实现步骤

**示例**：
```markdown
- 创建共享模块，实现统一的异常体系和响应类
- 配置应用启动模块的监控和追踪依赖
- 实现 API 层的全局异常处理器
```

**适用场景**：大部分任务

**优点**：
- 给执行者留有实现空间
- 关注结果而非过程
- 避免过度细节化

### 2. 步骤层（谨慎使用）

**特点**：列出主要步骤，但不涉及具体的代码细节

**示例**：
```markdown
- 创建共享模块，配置为库类型
- 实现异常体系：基础异常、业务异常、系统异常
- 实现统一响应类
- 创建包结构：exception、dto、constant、util
```

**适用场景**：复杂任务需要明确子步骤时

**注意事项**：
- 步骤应该是高层次的
- 避免涉及具体的配置项或代码行
- 保持在"做什么"的层面

### 3. 细节层（避免使用）

**特点**：详细到每个配置项、每行代码

**错误示例**：
```markdown
- 在项目根目录创建配置文件
- 配置项目组标识为 com.example.project
- 配置项目名称为 my-service
- 在配置中添加语言版本设置
- 在异常基类中添加错误码字段
```

**问题**：这是编码指令，不是任务描述，与直接编码没有区别

### 层次对比示例

**同一个任务的三种描述方式**：

**❌ 细节层（避免）**：
```markdown
- 在 common 目录下创建配置文件
- 在配置文件中添加父模块引用
- 在配置文件中添加模块标识
- 在配置文件中添加打包类型设置
- 在依赖配置中添加工具库依赖
- 创建源代码目录结构
- 在 exception 目录下创建基础异常类
- 在异常类中添加访问器注解
- 在异常类中添加错误码字段
```

**⚠️ 步骤层（谨慎使用）**：
```markdown
- 创建共享模块，配置为库类型，添加必要的工具依赖
- 实现异常体系：基础异常（抽象类）、业务异常、系统异常
- 实现统一响应类，包含 code、message、data 字段
- 创建包结构：exception、dto、constant、util
- 在根配置中声明共享模块
```

**✅ 目标层（推荐）**：
```markdown
- 创建共享模块，实现统一的异常体系和响应类
```

### 验收标准的编写

**重要**：验收标准应该详细，但要关注"如何验证"，而不是"如何实现"

**好的验收标准**：
```markdown
**验收标准**：
- 运行项目构建命令成功，输出构建成功信息
- 检查共享模块配置文件，确认父模块引用正确，打包类型为库类型
- 确认依赖配置包含必要的工具库，且版本由父配置管理
- 确认存在 4 个核心类：基础异常、业务异常、系统异常、统一响应类
- 检查基础异常类，确认有必要的访问器、错误码和消息字段
```

**特点**：
- 可执行的验证步骤
- 明确的检查点
- 具体的预期结果

### 实用技巧

#### 1. 使用"创建"、"实现"、"配置"等动词开头

```markdown
✅ 创建领域 API 模块，定义领域模型结构
✅ 实现 API 层的全局异常处理器
✅ 配置应用启动模块的监控端点
```

#### 2. 避免使用"添加"、"在...中"等细节性动词

```markdown
❌ 在配置文件中添加工具库依赖
❌ 在异常基类中添加错误码字段
```

#### 3. 关注"是什么"而不是"在哪里"

```markdown
✅ 创建统一的异常体系（基础异常、业务异常、系统异常）
❌ 在 common/src/exception 目录下创建基础异常类文件
```

#### 4. 验收标准要具体，但任务描述要抽象

```markdown
**任务描述**（抽象）：
- 创建共享模块，实现异常体系

**验收标准**（具体）：
- 确认存在基础异常、业务异常、系统异常三个类文件
- 检查基础异常类，确认有必要的访问器、错误码和消息字段
```

## 任务粒度的把握

### 合适的任务粒度

**单个任务应该**：
- 可以在 1-4 小时内完成
- 有明确的开始和结束
- 可以独立验证
- 产生可见的成果

### 任务过大的信号

- 需要超过 4 小时完成
- 包含多个不相关的功能
- 难以定义验收标准

**解决方案**：拆分为子任务

### 任务过小的信号

- 只需要几分钟完成
- 只是一个配置项或一行代码
- 无法独立验证

**解决方案**：合并到相关任务中

## 常见问题与应对

### 问题 1：任务粒度过大

**表现**：任务需要超过 4 小时完成，包含多个不相关的功能，难以定义验收标准。

**应对**：
- 将大任务拆分为多个子任务
- 每个子任务关注一个明确的目标
- 确保每个子任务可以独立验证

### 问题 2：任务粒度过小

**表现**：任务只需要几分钟完成，只是一个配置项或一行代码，无法独立验证。

**应对**：
- 将小任务合并到相关任务中
- 作为大任务的一个步骤或验收点
- 保持任务的独立性和完整性

### 问题 3：任务描述过于详细

**表现**：任务描述包含具体的代码实现、配置细节，读起来像编码指令。

**应对**：
- 任务应该描述"做什么"，而非"怎么做"
- 关注目标和结果，而非实现过程
- 给执行者留有实现空间
- 将实现细节留给编码阶段

### 问题 4：验收标准不明确

**表现**：验收标准模糊，无法判断任务是否完成，缺乏具体的验证方法。

**应对**：
- 使用 EARS 语法编写验收标准
- 提供具体的验证命令和步骤
- 明确预期的输出和结果
- 指定验证方法（运行时/构建/静态）

## 检查清单

在开始执行任务前，确认以下所有项：

- [ ] 已充分理解设计文档
- [ ] 已创建完整的任务列表
- [ ] 每个任务都有明确的目标和验收标准
- [ ] 任务描述关注"做什么"而不是"怎么做"
- [ ] 任务粒度合适（1-4 小时可完成）
- [ ] 任务之间的依赖关系清晰
- [ ] 验收标准具体、可执行、可测试
- [ ] 已进行任务列表验证（一致性、可执行性、可验证性）
- [ ] 任务列表完整覆盖了设计内容
- [ ] 没有超出设计范围的任务
- [ ] 已与用户确认任务列表
- [ ] 已获得用户对任务列表的明确认可

## 任务拆分的黄金法则

1. **任务描述要抽象**：说明要达成什么目标，而非如何实现
2. **验收标准要具体**：说明如何验证目标达成，提供具体步骤
3. **避免编码指令**：不要逐行告诉执行者怎么写代码
4. **关注结果而非过程**：描述要产生什么，而不是如何产生
5. **保持合适粒度**：1-4 小时可完成，可独立验证

## 关键收益

遵循任务拆分阶段最佳实践，可以：

- ✅ 确保任务可执行性，降低实施风险
- ✅ 提高开发效率和质量
- ✅ 便于进度跟踪和风险控制
- ✅ 支持并行开发和增量交付
- ✅ 确保交付物的可验证性

**记住**：任务是给开发者的目标指引，不是给 AI 的编码指令。如果任务描述读起来像是在写代码，那就说明太详细了。
