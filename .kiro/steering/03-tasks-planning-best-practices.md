---
inclusion: manual
---

## 阶段目标

将设计方案拆分为可独立执行、可验证的具体任务，确保每个任务都有明确的目标和验收标准。

## 为什么任务拆分如此重要

任务拆分是将设计转化为可执行步骤的关键环节。好的任务拆分可以：
- 提高开发效率和质量
- 降低任务间的耦合度
- 支持并行开发和增量交付
- 便于进度跟踪和风险控制
- 确保交付物的可验证性

**关键原则**：任务必须既可执行又可验证。

## 任务拆分工作流程

### 第一步：理解设计方案

在开始拆分任务前，充分理解设计文档。

**关键活动**：
- 通读设计文档，理解架构和模块划分
- 识别核心功能和依赖关系
- 标记技术难点和风险点
- 列出需要澄清的问题

### 第二步：创建任务列表

基于设计文档，将设计转化为可执行的任务列表。

**任务拆分原则**：

#### 1. 单一职责
每个任务只关注一个明确的目标，避免任务过于复杂。

**为什么重要**：
- 降低任务复杂度，易于理解和执行
- 便于独立验证和测试
- 减少任务间的耦合

#### 2. 可独立验证
每个任务完成后应该能够独立验证其正确性。

**为什么重要**：
- 及早发现问题，降低修复成本
- 确保每个任务的质量
- 支持增量交付

#### 3. 合理的依赖关系
任务之间的依赖应该清晰明确，避免循环依赖。

**为什么重要**：
- 明确任务执行顺序
- 支持并行开发
- 便于进度管理

#### 4. 增量交付
任务应该支持增量开发，每完成一个任务都应该让项目向前推进一步。

**为什么重要**：
- 持续产生价值
- 及早获得反馈
- 降低集成风险

### 第三步：编写任务描述

为每个任务编写清晰的描述和验收标准。

**任务内容要求**：

#### 1. 任务描述
- 清晰说明要实现什么功能或完成什么工作
- 描述"做什么"，而非"怎么做"
- 关注目标和结果，而非实现过程

#### 2. 前置条件（可选）
- 任务开始前需要满足的条件
- 依赖哪些其他任务
- 需要哪些前置资源或环境

#### 3. 验收标准（必需）
- 如何验证任务是否正确完成
- 必须具体、可执行、可测试
- **必须明确验证方式**：运行时验证、构建验证、单元测试、静态检查
- 按验证优先级排序：运行时 > 单元测试 > 构建 > 静态

### 第四步：任务列表验证

**关键**：任务列表创建完成后，不要立即开始执行，而是进行充分的验证。

**验证维度**：

#### 1. 与需求和设计的一致性
- [ ] 任务列表是否与需求和设计一致？
- [ ] 是否有超出设计范围的任务？
- [ ] 是否完整覆盖了设计中的所有内容？
- [ ] 是否有遗漏的功能或模块？

#### 2. 任务的可执行性
- [ ] 每个任务的目标是否明确？
- [ ] 任务的粒度是否合适（1-4 小时）？
- [ ] 任务之间的依赖关系是否清晰？
- [ ] 是否有循环依赖？

#### 3. 任务的可验证性
- [ ] 每个任务的验证标准是否明确？
- [ ] 验证标准是否具体、可执行？
- [ ] 验证方法是否可操作？
- [ ] 是否明确了验证优先级（运行时 > 构建 > 静态）？

**验证方法**：

使用以下提示词让 Kiro 进行自检：

> "请检查任务列表是否与需求和设计一致，是否有超出设计范围的任务。另外，请明确每个任务的验证标准，并对任务进行验证。"

### 第五步：用户确认

与用户确认任务列表，确保理解一致。

**必须确认的内容**：
- 任务拆分的粒度是否合适
- 任务优先级和顺序是否合理
- 是否有遗漏或不必要的任务
- 验收标准是否清晰可行

**只有在用户明确确认后，才能开始执行任务。**

## 验收原则

**核心要求**：每个验收标准都必须明确标注验证方式，使用【验证方式】标签。

任务验收应遵循以下优先级顺序：

### 1. 【运行时验证】（最优先）
能通过实际运行应用来验证的功能，必须通过运行应用进行验证。

**适用场景**：
- 配置验证（多环境、特性开关等）
- API 端点功能验证
- 日志输出格式验证
- 异常处理验证
- 集成功能验证
- 外部服务连接验证

**验证方法**：
- 启动应用（使用项目的启动命令）
- 访问相关端点或触发相关功能
- 检查实际运行结果是否符合预期

### 2. 【单元测试】（次优先）
业务逻辑和算法应该通过单元测试验证。

**适用场景**：
- Service 层业务逻辑
- 工具类方法
- 算法实现
- 数据转换逻辑

**验证方法**：
- 执行单元测试命令（如 `mvn test`）
- 检查测试覆盖率
- 验证所有测试用例通过

### 3. 【构建验证】（第三优先）
无法通过运行验证的结构性要求，通过构建项目进行验证。

**适用场景**：
- 模块/组件结构验证
- 依赖关系验证
- 构建配置验证
- 代码语法正确性验证

**验证方法**：
- 执行项目的构建命令确保构建成功
- 检查构建日志中的组件顺序和依赖关系
- 确认构建产物符合预期

### 4. 【静态检查】（最后）
仅在无法通过上述方式验证时，才使用静态文件检查。

**适用场景**：
- 文件存在性检查
- 配置文件内容检查
- 目录结构检查

**验证方法**：
- 检查文件是否存在
- 检查文件内容是否符合要求

**验证方式选择原则**：

优先选择更高层次的验证方式：
- 能运行验证的，不用单元测试
- 能单元测试的，不用构建验证
- 能构建验证的，不用静态检查
- 一个任务可以包含多种验证方式

## 任务描述的三个层次

**核心原则**：任务描述应该是"做什么"，而不是"怎么做"

任务拆分的目标是将设计转化为可执行的目标，而不是编写详细的编码指令。任务应该描述要达成的结果，而不是逐步的实现细节。

### 1. 目标层（推荐）

**特点**：描述要达成的结果，不涉及具体实现步骤

**适用场景**：大部分任务

**优点**：
- 给执行者留有实现空间
- 关注结果而非过程
- 避免过度细节化

### 2. 步骤层（谨慎使用）

**特点**：列出主要步骤，但不涉及具体的代码细节

**适用场景**：复杂任务需要明确子步骤时

**注意事项**：
- 步骤应该是高层次的
- 避免涉及具体的配置项或代码行
- 保持在"做什么"的层面

### 3. 细节层（避免使用）

**特点**：详细到每个配置项、每行代码

**问题**：这是编码指令，不是任务描述，与直接编码没有区别

### 验收标准的编写

**重要**：验收标准应该详细，但要关注"如何验证"，而不是"如何实现"

**特点**：
- 可执行的验证步骤
- 明确的检查点
- 具体的预期结果

### 实用技巧

#### 1. 使用"创建"、"实现"、"配置"等动词开头

推荐使用明确的动作动词来描述任务目标。

#### 2. 避免使用"添加"、"在...中"等细节性动词

避免使用过于具体的位置描述和细节性动词。

#### 3. 关注"是什么"而不是"在哪里"

任务描述应该关注要创建什么，而不是在哪里创建。

#### 4. 验收标准要具体，但任务描述要抽象

任务描述保持抽象层次，验收标准提供具体的验证步骤。

## 任务粒度的把握

### 合适的任务粒度

**单个任务应该**：
- 可以在 1-4 小时内完成
- 有明确的开始和结束
- 可以独立验证
- 产生可见的成果

### 任务过大的信号

- 需要超过 4 小时完成
- 包含多个不相关的功能
- 难以定义验收标准

**解决方案**：拆分为子任务

### 任务过小的信号

- 只需要几分钟完成
- 只是一个配置项或一行代码
- 无法独立验证

**解决方案**：合并到相关任务中

## 常见问题与应对

### 问题 1：任务粒度过大

**表现**：任务需要超过 4 小时完成，包含多个不相关的功能，难以定义验收标准。

**应对**：
- 将大任务拆分为多个子任务
- 每个子任务关注一个明确的目标
- 确保每个子任务可以独立验证

### 问题 2：任务粒度过小

**表现**：任务只需要几分钟完成，只是一个配置项或一行代码，无法独立验证。

**应对**：
- 将小任务合并到相关任务中
- 作为大任务的一个步骤或验收点
- 保持任务的独立性和完整性

### 问题 3：任务描述过于详细

**表现**：任务描述包含具体的代码实现、配置细节，读起来像编码指令。

**应对**：
- 任务应该描述"做什么"，而非"怎么做"
- 关注目标和结果，而非实现过程
- 给执行者留有实现空间
- 将实现细节留给编码阶段

### 问题 4：验收标准不明确

**表现**：验收标准模糊，无法判断任务是否完成，缺乏具体的验证方法。

**应对**：
- 使用 EARS 语法编写验收标准
- 提供具体的验证命令和步骤
- 明确预期的输出和结果
- 指定验证方法（运行时/构建/静态）

## 检查清单

在开始执行任务前，确认以下所有项：

- [ ] 已充分理解设计文档
- [ ] 已创建完整的任务列表
- [ ] 每个任务都有明确的目标和验收标准
- [ ] 任务描述关注"做什么"而不是"怎么做"
- [ ] 任务粒度合适（1-4 小时可完成）
- [ ] 任务之间的依赖关系清晰
- [ ] 验收标准具体、可执行、可测试
- [ ] 已进行任务列表验证（一致性、可执行性、可验证性）
- [ ] 任务列表完整覆盖了设计内容
- [ ] 没有超出设计范围的任务
- [ ] 已与用户确认任务列表
- [ ] 已获得用户对任务列表的明确认可

## 优秀任务示例

以下是一个符合最佳实践的任务示例，展示了标准的任务格式：

### 示例：创建图构建器核心功能

**任务描述**：
- [x] 4. 创建图构建器核心功能
  - 编写 GraphBuilder 类使用 LangGraph 技术构建协作图
  - 实现团队图和监督者图的构建方法
  - 创建节点和边的定义逻辑
  - **验证方法**: 测试图构建成功，验证节点和边的正确性，检查 LangGraph 编译无错误
  - _需求: 1.1, 4.3_

**示例分析**：

1. **任务标识清晰**：使用简单数字编号（4.）便于引用和跟踪
2. **目标明确**：创建图构建器核心功能
3. **关键要点列举**：
   - 使用 LangGraph 技术构建协作图
   - 实现团队图和监督者图的构建方法
   - 创建节点和边的定义逻辑
4. **验证方法明确**：
   - 测试图构建成功
   - 验证节点和边的正确性
   - 检查 LangGraph 编译无错误
5. **需求追溯**：明确关联需求 1.1 和 4.3

**格式要点**：
- 使用 `- [x]` 或 `- [ ]` 标记任务状态
- **任务编号必须使用简单数字格式（如 1., 2., 3.），禁止使用分层格式（如 1.1, 2.1, 3.1）**
- 关键实现要点使用子项列出
- **验证方法** 使用粗体标注，清晰说明如何验证
- 使用 `_需求:_` 标注需求追溯关系

**任务编号规范**：
- ✅ **正确格式**：`- [ ] 1. 创建 Maven 父工程`
- ❌ **错误格式**：`- [ ] 1.1 创建 Maven 父工程`
- **原因**：Kiro 的任务执行功能要求使用简单数字编号，分层编号会导致执行按钮无法显示

**为什么这是好的任务**：
- ✅ 描述"做什么"而非"怎么做"
- ✅ 目标清晰，范围明确
- ✅ 验证标准具体可执行
- ✅ 粒度合适（预计 2-3 小时）
- ✅ 可独立验证
- ✅ 与需求可追溯

## 任务拆分的黄金法则

1. **任务描述要抽象**：说明要达成什么目标，而非如何实现
2. **验收标准要具体**：说明如何验证目标达成，提供具体步骤
3. **避免编码指令**：不要逐行告诉执行者怎么写代码
4. **关注结果而非过程**：描述要产生什么，而不是如何产生
5. **保持合适粒度**：1-4 小时可完成，可独立验证

## 关键收益

遵循任务拆分阶段最佳实践，可以：

- ✅ 确保任务可执行性，降低实施风险
- ✅ 提高开发效率和质量
- ✅ 便于进度跟踪和风险控制
- ✅ 支持并行开发和增量交付
- ✅ 确保交付物的可验证性

**记住**：任务是给开发者的目标指引，不是给 AI 的编码指令。如果任务描述读起来像是在写代码，那就说明太详细了。
