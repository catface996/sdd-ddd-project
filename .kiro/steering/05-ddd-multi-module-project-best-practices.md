---
inclusion: manual
---

# DDD 多模块 Maven 项目最佳实践

本文档专门针对基于 DDD（领域驱动设计）的多模块 Maven 项目开发的最佳实践。

## 适用范围

本文档适用于以下类型的项目：
- 使用 Maven 作为构建工具的多模块项目
- 采用 DDD 分层架构的 Java 项目
- 使用 Spring Boot 框架的应用

## 文档结构

本文档按照 Spec 开发流程组织内容：
1. **设计阶段**：ADR 示例和架构决策
2. **任务执行阶段**：渐进式模块声明和验证标准
3. **项目结构**：模块分层和依赖关系
4. **Maven 配置**：父 POM 管理和子模块配置
5. **Spring Boot 集成**：Actuator、日志、异常处理
6. **验收标准示例**：具体的验证方法

## 一、设计阶段指南

### ADR 示例

在 DDD 多模块 Maven 项目的设计阶段，以下是典型的架构决策记录示例。这些示例展示了如何记录重要的技术选型和架构决策。

**注意**：只有重要的架构级别决策才需要记录 ADR，不是所有技术选择都需要。

### ADR-001：选择 MyBatis-Plus 而非 JPA

- **状态**：已接受
- **背景**：需要选择 ORM 框架来实现数据持久化
- **决策**：选择 MyBatis-Plus 作为 ORM 框架
- **理由**：
  - 更灵活的 SQL 控制，便于性能优化
  - 更好的复杂查询支持
  - 团队对 MyBatis 熟悉度高
  - 简化 CRUD 操作，提供代码生成器
- **后果**：
  - 正面：SQL 可控性强，性能优化灵活，学习成本低
  - 负面：需要手动编写复杂查询的 SQL，相比 JPA 需要更多配置

**说明**：这个示例展示了如何记录技术选型决策，包括备选方案对比和权衡分析。

### ADR-002：采用 DDD 分层架构

- **状态**：已接受
- **背景**：需要确定项目的整体架构模式
- **决策**：采用 DDD（领域驱动设计）分层架构
- **理由**：
  - 业务逻辑复杂，需要清晰的领域模型
  - 分层架构便于职责划分和团队协作
  - 领域层独立，便于测试和维护
  - 符合团队技术栈和经验
- **后果**：
  - 正面：清晰的模块边界，高内聚低耦合，易于维护和扩展
  - 负面：初期搭建成本较高，需要团队理解 DDD 概念

**说明**：这个示例展示了如何记录架构模式决策，这类决策会影响整个项目的结构。

## 二、任务执行阶段指南

在 DDD 多模块 Maven 项目的任务执行阶段，需要特别注意以下事项：

### 渐进式模块声明的重要性

**问题场景**：

在多模块 Maven 项目中，如果在父 POM 中预先声明了所有子模块，但这些模块尚未创建，会导致编译失败：

```
[ERROR] Child module /path/to/module does not exist
```

**解决方案**：渐进式模块声明

#### 1. 只声明已创建的模块
- 在父 POM 的 `<modules>` 节中，只包含已经实际创建的模块
- 不要预先声明计划中但尚未创建的模块

#### 2. 创建模块时同步更新父 POM
- 每创建一个新模块后，立即在父 POM 中添加该模块的声明
- 确保模块声明与实际目录结构保持同步

#### 3. 多层级模块的处理
- 对于有子模块的父模块（如 infrastructure），同样遵循此原则
- 父模块的 `<modules>` 节也应该只声明已创建的子模块

### 实施步骤示例

以创建 infrastructure 父模块为例：

1. 创建 infrastructure/pom.xml，暂时不声明子模块
2. 在根 pom.xml 中添加 infrastructure 模块声明
3. 运行 `mvn clean compile` 验证成功
4. 后续创建子模块（repository、cache、mq）时，再逐个添加到 infrastructure/pom.xml 的 `<modules>` 节中

### 注意事项

1. 不要一次性声明所有计划中的模块
2. 每次修改 POM 后都要验证编译
3. 保持模块声明顺序与依赖关系一致
4. 对于父模块，先创建父 POM，再逐步添加子模块
5. 遇到编译错误时，优先检查模块声明和依赖配置

### 任务完成检查清单（Maven 项目特定）

- [ ] 代码已提交到正确的位置
- [ ] 相关 POM 文件已更新
- [ ] 项目可以成功编译（`mvn clean compile`）
- [ ] 没有编译错误或警告
- [ ] 模块声明与实际目录结构一致
- [ ] 依赖关系配置正确
- [ ] 所有依赖都未指定版本号（由父 POM 管理）
- [ ] **如果功能可运行验证，已通过运行应用进行验证**
- [ ] **如果是结构性变更，已通过编译验证**

## 三、项目结构规范

### 模块分层

DDD 多模块项目通常采用以下分层结构：

- **common**：通用模块，包含异常体系、响应类、工具类等
- **domain-api**：领域 API 模块，定义领域模型接口
- **domain**：领域实现模块，实现核心业务逻辑
- **infrastructure**：基础设施层，包含数据访问、缓存、消息队列等
- **application**：应用服务层，编排领域服务
- **http**：HTTP 接口层，提供 REST API
- **bootstrap**：启动模块，应用程序入口

### 依赖关系

模块间的依赖应遵循 DDD 分层架构原则：

```
bootstrap → application → domain → domain-api
         ↓              ↓        ↓
         http    →  infrastructure
         ↓              ↓
         common  ←  ←  ←
```

## 四、Maven 配置规范

### 父 POM 管理

#### 1. 统一版本管理

- 在父 POM 的 `<dependencyManagement>` 中统一管理所有依赖版本
- 包括 Spring Boot、第三方库、内部模块的版本
- 使用 `<properties>` 定义版本号变量

#### 2. 渐进式模块声明

- 在 `<modules>` 节中只声明已创建的模块
- 不要预先声明计划中但尚未创建的模块
- 创建新模块后立即添加声明

### 子模块配置

#### 1. 引用父 POM

- 每个子模块的 `<parent>` 节必须引用父 POM
- 指定正确的 groupId、artifactId 和 version

#### 2. 依赖版本管理

- 子模块引用依赖时不指定版本号
- 版本由父 POM 的 `<dependencyManagement>` 统一管理
- 确保依赖版本的一致性

## 五、模块创建流程

### 标准流程

1. **创建模块目录和 pom.xml**
2. **在父 POM 中添加模块声明**
3. **验证编译**：`mvn clean compile`
4. **创建源代码结构**
5. **实现功能**
6. **再次验证编译**

### 多层级模块处理

对于有子模块的父模块（如 infrastructure），遵循相同原则：

1. 先创建父模块（infrastructure）
2. 在根 POM 中声明 infrastructure
3. 验证编译
4. 创建子模块（repository、cache、mq）
5. 在 infrastructure/pom.xml 中逐个声明子模块
6. 每次添加后都验证编译

## 六、验证标准

### 编译验证

每个任务完成后必须执行 `mvn clean compile`，确保：
- 输出包含 "BUILD SUCCESS"
- Reactor Build Order 列出所有已声明的模块
- 没有任何 ERROR 信息

### 打包验证

对于 bootstrap 模块，执行 `mvn clean package`，确保：
- bootstrap/target 目录下生成可执行 JAR
- JAR 文件名包含版本号

### 运行时验证

对于可运行的功能，启动应用验证：
- 使用 `mvn spring-boot:run` 或运行 JAR 文件
- 访问相关端点验证功能
- 检查日志输出和响应结果

## 七、常见问题处理

### 模块未找到错误

```
[ERROR] Child module /path/to/module does not exist
```

**原因**：在 POM 中声明了尚未创建的模块

**解决**：
1. 从 POM 中移除该模块声明
2. 创建模块后再添加声明

### 依赖版本冲突

```
[WARNING] Some problems were encountered while building the effective model
```

**原因**：子模块指定了与父 POM 不同的版本

**解决**：
1. 移除子模块中的版本号声明
2. 在父 POM 的 dependencyManagement 中统一管理

### 循环依赖

```
[ERROR] The projects in the reactor contain a cyclic reference
```

**原因**：模块间存在循环依赖

**解决**：
1. 检查模块依赖关系
2. 重新设计模块边界
3. 遵循 DDD 分层原则

## 八、Spring Boot 集成规范

### Actuator 配置

在 bootstrap 模块的 application.yml 中配置监控端点：
- 暴露必要的端点（health、info、prometheus、metrics）
- 配置健康检查详细信息显示级别
- 注意端点安全配置，避免信息泄露

### 日志配置

配置结构化日志：
- 使用 JSON 格式输出日志
- 包含 timestamp、level、traceId、spanId、message 等字段
- 支持分布式追踪

### 异常处理

在 http 模块实现全局异常处理器：
- 使用 `@RestControllerAdvice` 统一处理异常
- 区分业务异常和系统异常
- 返回统一的响应格式（Result 对象）
- HTTP 状态码为 200，业务错误通过 code 字段表示

## 九、验收标准编写指南

以下是 DDD 多模块 Maven 项目中常见任务的验收标准编写要点：

### 模块结构验证

- 执行 `mvn clean compile` 验证编译成功
- 检查 Reactor Build Order 确认模块顺序
- 确认所有模块的 pom.xml 引用父 POM
- 确认依赖版本由父 POM 统一管理

### Prometheus 集成验证

- 启动应用后访问 Prometheus 端点
- 确认返回正确格式的指标数据
- 确认包含必要的监控指标

### 日志格式验证

- 启动应用后检查日志输出
- 确认日志格式符合要求（JSON 格式）
- 确认包含必要的追踪字段（traceId、spanId）

### 异常处理验证

- 触发业务异常验证响应格式
- 确认响应包含必要字段（code、message、data）
- 确认 HTTP 状态码和业务错误码的使用规范

## 十、关键原则总结

### DDD 架构原则

1. **严格分层**：遵循 DDD 分层原则，避免跨层依赖
2. **单一职责**：保持模块职责单一，避免模块过于庞大
3. **依赖方向**：依赖关系应该从外层指向内层，领域层不依赖基础设施层

### Maven 管理原则

1. **统一版本管理**：使用父 POM 管理所有依赖版本
2. **渐进式声明**：只声明已创建的模块，避免预先声明
3. **持续验证**：每次修改 POM 后都要验证编译

### 验证原则

1. **优先级顺序**：运行时验证 > 构建验证 > 静态检查
2. **及时验证**：每个任务完成后立即验证
3. **完整验证**：确保所有验收标准都通过

### 代码质量原则

1. **编码规范**：遵循统一的代码风格和命名规范
2. **错误处理**：实现统一的异常处理机制
3. **可观测性**：配置日志、监控、链路追踪

## 关键收益

遵循这些最佳实践，可以获得：

- ✅ 清晰的模块边界和职责划分
- ✅ 统一的依赖版本管理
- ✅ 符合 DDD 分层架构原则
- ✅ 便于持续集成和自动化测试
- ✅ 支持增量开发和迭代交付
- ✅ 降低模块间耦合度
- ✅ 提高代码质量和可维护性
