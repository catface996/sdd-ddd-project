# 技术设计阶段评分标准

## 评分总则

- **评分制度**：扣分制（满分100分）
- **评分时机**：设计文档完成验证后
- **评分原则**：从完美状态开始，发现问题扣分

---

## 评分维度（100分）

### 1. 需求覆盖度（25分）

需求覆盖度评估设计是否完全覆盖了需求文档中的所有内容。设计遗漏需求会导致功能缺失，需要后期返工。

#### 1.1 功能覆盖（15分）

**评分项说明**：
- **遗漏需求功能**：-5分/项
- **部分覆盖需求**：-3分/项

**详细说明**：

**遗漏需求功能 vs 部分覆盖需求的判断标准**：

**遗漏需求功能（-5分/项）**：
- **定义**：需求中明确要求的功能，在设计中完全没有体现
- **影响**：功能无法实现，必须补充设计
- **特征**：设计文档中找不到任何相关的设计内容

**示例 1：完全遗漏核心功能**
- **需求**：用户可以导出项目列表为 Excel 文件
- **设计**：只设计了项目的 CRUD 接口，未设计导出功能
- **问题**：完全遗漏了导出功能的设计
- **扣分**：-5分
- **影响**：无法实现导出功能

**示例 2：遗漏异常处理**
- **需求**：当文件上传失败时，系统应该重试 3 次，并记录失败日志
- **设计**：只设计了文件上传的正常流程，未设计重试机制和日志记录
- **问题**：遗漏了异常处理的设计
- **扣分**：-5分
- **影响**：系统无法正确处理上传失败的情况

**示例 3：遗漏权限控制**
- **需求**：普通用户只能查看自己创建的项目，管理员可以查看所有项目
- **设计**：只设计了项目查询接口，未设计权限控制机制
- **问题**：遗漏了权限控制的设计
- **扣分**：-5分
- **影响**：存在安全隐患

---

**部分覆盖需求（-3分/项）**：
- **定义**：设计覆盖了需求的主要部分，但遗漏了部分细节或场景
- **影响**：功能不完整，需要补充设计细节
- **特征**：设计有相关内容，但不够完整

**示例 1：遗漏部分场景**
- **需求**：用户可以按创建时间、更新时间、名称排序项目列表
- **设计**：只设计了按创建时间排序的接口
- **问题**：遗漏了按更新时间和名称排序的设计
- **扣分**：-3分
- **影响**：功能不完整，需要补充排序选项

**示例 2：遗漏边界条件**
- **需求**：用户可以上传文件，文件大小不超过 10MB，支持 PDF、Word、Excel 格式
- **设计**：设计了文件上传接口，但未设计文件大小和格式的校验
- **问题**：遗漏了边界条件的设计
- **扣分**：-3分
- **影响**：无法正确处理超大文件和不支持的格式

**示例 3：遗漏状态转换**
- **需求**：订单状态包括：待支付、已支付、已发货、已完成、已取消
- **设计**：设计了订单状态字段，但未设计状态转换规则和限制
- **问题**：遗漏了状态转换的设计
- **扣分**：-3分
- **影响**：可能出现非法的状态转换

---

**如何识别遗漏**：

1. **需求对照检查**：
   - 将需求文档中的每个功能点与设计文档对照
   - 确认每个功能点都有对应的设计方案
   - 使用检查清单逐项核对

2. **场景覆盖检查**：
   - 列出所有用户场景
   - 确认每个场景都有对应的设计
   - 检查正常场景和异常场景

3. **流程完整性检查**：
   - 检查业务流程是否完整（开始→处理→结束）
   - 确认每个步骤都有设计支持
   - 检查流程分支和异常处理

4. **接口完整性检查**：
   - 确认所有需要的接口都已设计
   - 检查接口的输入输出是否完整
   - 确认接口能支持所有需求场景

**检查要点**：
- [ ] 是否完全覆盖了需求文档中的所有功能？
- [ ] 是否为每个需求提供了设计方案？
- [ ] 是否考虑了所有用户场景？
- [ ] 是否设计了正常流程和异常流程？
- [ ] 是否考虑了边界条件和约束？

---

#### 1.2 非功能性需求覆盖（10分）

**评分项说明**：
- **未设计性能方案**：-5分
- **未设计安全方案**：-3分
- **未考虑可维护性**：-2分

**详细说明**：

**1. 未设计性能方案（-5分）**

**为什么重要**：
- 性能问题在生产环境才暴露，修复成本极高
- 性能设计需要在架构层面考虑
- 后期优化往往需要重构

**应该包含的性能设计**：

**缓存设计**：
- **需求**：API 响应时间 < 200ms
- **设计应包含**：
  - 缓存策略（Redis、本地缓存）
  - 缓存的数据类型和过期时间
  - 缓存更新和失效机制
- **示例**：
  ```
  - 用户信息缓存在 Redis，过期时间 30 分钟
  - 项目列表缓存在本地内存，过期时间 5 分钟
  - 当项目更新时，主动失效相关缓存
  ```

**数据库优化设计**：
- **需求**：支持 1000 QPS 的查询
- **设计应包含**：
  - 索引设计（哪些字段需要索引）
  - 查询优化（避免 N+1 查询）
  - 连接池配置
- **示例**：
  ```
  - 在 user_id、create_time 字段上建立联合索引
  - 使用批量查询避免 N+1 问题
  - 连接池大小设置为 20
  ```

**异步处理设计**：
- **需求**：文件上传后需要进行病毒扫描和格式转换
- **设计应包含**：
  - 异步任务队列（RabbitMQ、Kafka）
  - 任务处理流程
  - 失败重试机制
- **示例**：
  ```
  - 文件上传后立即返回，将扫描任务放入 RabbitMQ
  - 后台 Worker 消费任务进行扫描
  - 扫描失败重试 3 次，失败后记录日志
  ```

**评分示例**：
- **完全未设计性能方案**：-5分
- **只设计了部分性能方案**（如只有缓存，没有数据库优化）：-3分
- **性能设计不具体**（如"使用缓存提升性能"）：-2分

---

**2. 未设计安全方案（-3分）**

**为什么重要**：
- 安全问题可能导致数据泄露、系统被攻击
- 安全设计需要在架构层面考虑
- 后期补救成本高，可能需要重构

**应该包含的安全设计**：

**认证设计**：
- **需求**：用户需要登录才能访问系统
- **设计应包含**：
  - 认证方式（JWT、Session）
  - Token 生成和验证机制
  - Token 过期和刷新策略
- **示例**：
  ```
  - 使用 JWT Token 进行认证
  - Token 有效期 2 小时，Refresh Token 有效期 7 天
  - Token 存储在 HTTP-Only Cookie 中
  ```

**授权设计**：
- **需求**：不同角色有不同的操作权限
- **设计应包含**：
  - 权限模型（RBAC、ABAC）
  - 角色和权限的定义
  - 权限检查机制
- **示例**：
  ```
  - 采用 RBAC 模型，定义角色：管理员、普通用户
  - 管理员可以执行所有操作
  - 普通用户只能操作自己创建的资源
  - 在 API 层使用拦截器进行权限检查
  ```

**数据保护设计**：
- **需求**：敏感数据需要加密存储
- **设计应包含**：
  - 加密算法（AES、RSA）
  - 密钥管理方案
  - 传输加密（HTTPS）
- **示例**：
  ```
  - 密码使用 BCrypt 加密存储
  - 身份证号使用 AES-256 加密存储
  - 密钥存储在 AWS KMS
  - 所有 API 使用 HTTPS 传输
  ```

**防攻击设计**：
- **需求**：系统需要防止常见的 Web 攻击
- **设计应包含**：
  - SQL 注入防护（参数化查询）
  - XSS 防护（输入过滤、输出转义）
  - CSRF 防护（Token 验证）
  - 限流防护（防止 DDoS）
- **示例**：
  ```
  - 使用 MyBatis 参数化查询防止 SQL 注入
  - 使用 Spring Security 的 XSS 过滤器
  - 使用 CSRF Token 防止跨站请求伪造
  - 使用 Guava RateLimiter 限制 API 调用频率
  ```

**评分示例**：
- **完全未设计安全方案**：-3分
- **只设计了认证，未设计授权和数据保护**：-2分
- **安全设计不具体**（如"系统应该安全"）：-2分

---

**3. 未考虑可维护性（-2分）**

**为什么重要**：
- 系统上线后需要持续维护和问题排查
- 可维护性设计影响故障恢复时间
- 影响开发效率和运维成本

**应该包含的可维护性设计**：

**日志设计**：
- **需求**：系统需要记录操作日志以便问题排查
- **设计应包含**：
  - 日志级别（DEBUG、INFO、WARN、ERROR）
  - 日志内容（请求 ID、用户 ID、操作、耗时）
  - 日志格式（JSON、文本）
  - 日志存储（文件、ELK）
- **示例**：
  ```
  - 使用 SLF4J + Logback 记录日志
  - 日志格式：JSON，包含 requestId、userId、action、duration
  - INFO 级别记录所有 API 请求和响应
  - ERROR 级别记录所有异常和错误
  - 日志输出到文件，并通过 Filebeat 发送到 ELK
  ```

**监控设计**：
- **需求**：系统需要监控关键指标
- **设计应包含**：
  - 监控指标（响应时间、错误率、QPS）
  - 监控工具（Prometheus、Grafana）
  - 告警规则
- **示例**：
  ```
  - 使用 Micrometer 暴露指标
  - 监控指标：API 响应时间、错误率、QPS、JVM 内存
  - 使用 Prometheus 采集指标，Grafana 展示
  - 告警规则：错误率 > 1% 或响应时间 > 500ms 时发送告警
  ```

**错误处理设计**：
- **需求**：系统需要统一处理错误
- **设计应包含**：
  - 异常分类（业务异常、系统异常）
  - 错误码定义
  - 统一错误响应格式
- **示例**：
  ```
  - 定义异常体系：BaseException、BusinessException、SystemException
  - 错误码规则：1xxx 业务错误，2xxx 系统错误
  - 统一响应格式：{code, message, data}
  - 使用全局异常处理器统一处理异常
  ```

**配置管理设计**：
- **需求**：系统需要支持多环境配置
- **设计应包含**：
  - 配置中心（Nacos、Apollo）
  - 配置分类（数据库、缓存、第三方服务）
  - 配置热更新机制
- **示例**：
  ```
  - 使用 Nacos 作为配置中心
  - 配置按环境分类：dev、test、prod
  - 支持配置热更新，无需重启应用
  - 敏感配置（密码、密钥）加密存储
  ```

**评分示例**：
- **完全未考虑可维护性**：-2分
- **只设计了日志，未设计监控和错误处理**：-1分

---

**检查要点**：
- [ ] 是否设计了性能优化方案？
- [ ] 是否设计了安全防护机制？
- [ ] 是否考虑了可维护性（日志、监控、错误处理）？
- [ ] 是否考虑了可扩展性？
- [ ] 非功能性设计是否具体、可实施？

---

### 2. 设计合理性（30分）

设计合理性评估设计方案是否合理、可行，技术选型是否恰当。不合理的设计会导致实现困难、性能问题或维护成本高。

#### 2.1 架构设计（15分）

**评分项说明**：
- **架构选型不合理**：-10分
- **模块划分不清晰**：-5分
- **依赖关系混乱**：-5分

**详细说明**：

**1. 架构选型不合理（-10分）**

**什么是架构选型不合理**：
- 架构模式与项目规模、复杂度不匹配
- 架构选择未考虑团队能力和项目约束
- 架构过于复杂或过于简单

**常见不合理的架构选型**：

**类型 1：过度设计 - 小项目用复杂架构**
- **场景**：内部使用的简单管理系统，用户 < 100
- **不合理设计**：采用微服务架构，拆分 10+ 个服务
- **问题**：
  - 开发成本高（需要服务注册、配置中心、网关等）
  - 运维复杂度高（需要管理多个服务）
  - 团队规模小，无法支撑微服务开发
- **扣分**：-10分
- **合理设计**：采用分层架构的单体应用

**类型 2：设计不足 - 大项目用简单架构**
- **场景**：面向公众的 SaaS 平台，预期用户 > 100万
- **不合理设计**：采用单体架构，所有功能在一个应用中
- **问题**：
  - 无法水平扩展
  - 单点故障风险高
  - 代码耦合度高，难以维护
- **扣分**：-10分
- **合理设计**：采用微服务或模块化单体架构

**类型 3：技术栈不匹配**
- **场景**：需要高性能实时处理的系统
- **不合理设计**：使用 PHP + MySQL 同步处理
- **问题**：
  - PHP 不适合高并发场景
  - 同步处理无法满足性能要求
- **扣分**：-10分
- **合理设计**：使用 Java/Go + 消息队列异步处理

**类型 4：未考虑团队能力**
- **场景**：团队只熟悉 Java Spring Boot
- **不合理设计**：采用 Go + gRPC + Kubernetes
- **问题**：
  - 团队学习成本高
  - 开发效率低
  - 风险高
- **扣分**：-10分
- **合理设计**：使用团队熟悉的 Java Spring Boot

**如何判断架构选型是否合理**：

1. **规模匹配**：
   - 小项目（用户 < 1000）：单体架构
   - 中型项目（用户 1000-10万）：模块化单体或微服务
   - 大型项目（用户 > 10万）：微服务架构

2. **复杂度匹配**：
   - 简单业务：三层架构
   - 中等复杂业务：DDD 分层架构
   - 复杂业务：DDD + 事件驱动

3. **团队能力匹配**：
   - 优先使用团队熟悉的技术
   - 新技术需要评估学习成本
   - 考虑团队规模和技能分布

4. **约束匹配**：
   - 考虑时间约束（快速上线 vs 长期维护）
   - 考虑成本约束（开发成本 vs 运维成本）
   - 考虑技术约束（现有系统、技术栈）

---

**2. 模块划分不清晰（-5分）**

**什么是模块划分不清晰**：
- 模块职责不明确，边界模糊
- 模块之间职责重叠或遗漏
- 模块粒度不合理（过大或过小）

**常见模块划分问题**：

**问题 1：职责不明确**
- **不合理设计**：
  ```
  - UserModule：用户管理、订单管理、支付管理
  ```
- **问题**：UserModule 包含了太多不相关的职责
- **扣分**：-5分
- **合理设计**：
  ```
  - UserModule：用户管理（注册、登录、个人信息）
  - OrderModule：订单管理（创建、查询、取消订单）
  - PaymentModule：支付管理（支付、退款）
  ```

**问题 2：职责重叠**
- **不合理设计**：
  ```
  - UserService：用户注册、登录、权限验证
  - AuthService：用户认证、权限验证、Token 管理
  ```
- **问题**：权限验证在两个模块中都有，职责重叠
- **扣分**：-5分
- **合理设计**：
  ```
  - UserService：用户注册、用户信息管理
  - AuthService：用户认证、权限验证、Token 管理
  ```

**问题 3：模块粒度过大**
- **不合理设计**：
  ```
  - BusinessModule：包含所有业务逻辑
  ```
- **问题**：模块过大，难以维护
- **扣分**：-5分
- **合理设计**：按业务领域拆分为多个模块

**问题 4：模块粒度过小**
- **不合理设计**：
  ```
  - UserCreateModule：用户创建
  - UserUpdateModule：用户更新
  - UserDeleteModule：用户删除
  - UserQueryModule：用户查询
  ```
- **问题**：模块过小，增加复杂度
- **扣分**：-3分
- **合理设计**：
  ```
  - UserModule：用户 CRUD 操作
  ```

**模块划分原则**：
1. **单一职责**：每个模块只负责一个业务领域
2. **高内聚**：模块内部功能紧密相关
3. **低耦合**：模块之间依赖最小化
4. **合理粒度**：不要过大也不要过小

---

**3. 依赖关系混乱（-5分）**

**什么是依赖关系混乱**：
- 存在循环依赖
- 依赖方向错误（如领域层依赖基础设施层）
- 依赖关系过于复杂

**常见依赖问题**：

**问题 1：循环依赖**
- **不合理设计**：
  ```
  - UserService 依赖 OrderService
  - OrderService 依赖 UserService
  ```
- **问题**：循环依赖导致模块无法独立测试和部署
- **扣分**：-5分
- **解决方案**：
  - 提取公共接口
  - 使用事件解耦
  - 重新划分模块职责

**问题 2：违反依赖倒置原则（DDD 项目）**
- **不合理设计**：
  ```
  - Domain 层直接依赖 Infrastructure 层的具体实现
  ```
- **问题**：违反 DDD 分层架构原则
- **扣分**：-5分
- **合理设计**：
  ```
  - Domain 层定义接口
  - Infrastructure 层实现接口
  - 通过依赖注入使用
  ```

**问题 3：依赖层次混乱**
- **不合理设计**：
  ```
  - Controller 直接调用 Repository
  - Service 直接操作数据库
  ```
- **问题**：跨层调用，破坏分层架构
- **扣分**：-5分
- **合理设计**：
  ```
  - Controller → Service → Repository
  - 严格遵循分层调用
  ```

**问题 4：过度依赖**
- **不合理设计**：
  ```
  - UserService 依赖 10+ 个其他 Service
  ```
- **问题**：依赖过多，耦合度高
- **扣分**：-3分
- **解决方案**：
  - 重新审视模块划分
  - 使用事件解耦
  - 提取公共服务

**依赖关系设计原则**：
1. **无循环依赖**：模块之间不能循环依赖
2. **依赖方向正确**：遵循分层架构的依赖方向
3. **最小依赖**：只依赖必要的模块
4. **依赖抽象**：依赖接口而非具体实现

---

**检查要点**：
- [ ] 架构选型是否符合项目规模和复杂度？
- [ ] 模块职责是否清晰，边界是否明确？
- [ ] 依赖关系是否合理，是否存在循环依赖？
- [ ] 是否符合 DDD 分层架构原则（如适用）？
- [ ] 是否考虑了团队能力和项目约束？

---

#### 2.2 技术选型（15分）

**评分项说明**：
- **技术选型缺乏依据**：-5分/项
- **技术栈不兼容**：-10分
- **未考虑团队能力**：-3分

**详细说明**：

**1. 技术选型缺乏依据（-5分/项）**

**什么是缺乏依据**：
- 选择了某个技术，但没有说明为什么选择它
- 没有对比其他备选方案
- 没有评估技术的优缺点

**为什么需要依据**：
- 帮助团队理解技术选择的理由
- 便于后续评审和调整
- 记录决策过程，避免重复讨论

**应该使用 ADR（架构决策记录）**：

**ADR 模板**：
```markdown
## ADR-001：选择 MySQL 作为主数据库

**状态**：已接受

**背景**：
- 需要选择数据存储方案
- 数据具有明确的关系结构
- 需要 ACID 事务保证
- 需要复杂查询和聚合能力

**决策**：选择 MySQL 8.0 作为主数据库

**理由**：
- 数据具有明确的关系结构，适合关系型数据库
- 需要 ACID 事务保证，MySQL 完全支持
- 团队熟悉 MySQL，学习成本低
- MySQL 生态成熟，工具丰富
- 性能满足需求（支持 1000 QPS）

**备选方案**：
- PostgreSQL：功能更强大，但团队不熟悉
- MongoDB：适合文档型数据，但不适合关系型数据

**后果**：
- 正面：数据一致性强，查询能力强，生态成熟
- 负面：水平扩展相对困难，需要考虑分库分表
```

**常见缺乏依据的情况**：

**示例 1：数据库选型**
- ❌ 缺乏依据：使用 MySQL 数据库
- ✅ 有依据：使用 MySQL 8.0，因为数据具有关系结构，需要事务支持，团队熟悉
- **扣分**：-5分

**示例 2：缓存选型**
- ❌ 缺乏依据：使用 Redis 缓存
- ✅ 有依据：使用 Redis 6.0，因为需要高性能缓存，支持多种数据结构，支持持久化
- **扣分**：-5分

**示例 3：消息队列选型**
- ❌ 缺乏依据：使用 RabbitMQ
- ✅ 有依据：使用 RabbitMQ 3.9，因为需要可靠的消息传递，支持多种消息模式，团队有使用经验
- **扣分**：-5分

---

**2. 技术栈不兼容（-10分）**

**什么是技术栈不兼容**：
- 选择的技术之间无法协同工作
- 版本不兼容
- 技术之间存在冲突

**常见不兼容问题**：

**问题 1：版本不兼容**
- **不合理设计**：
  ```
  - Spring Boot 3.4.1（需要 JDK 17+）
  - MyBatis-Plus 3.5.3（使用 mybatis-plus-boot-starter，仅支持 Spring Boot 2）
  ```
- **问题**：MyBatis-Plus 的 Spring Boot 2 启动器与 Spring Boot 3 不兼容
- **扣分**：-10分
- **正确设计**：
  ```
  - Spring Boot 3.4.1
  - MyBatis-Plus 3.5.7（使用 mybatis-plus-spring-boot3-starter）
  ```

**问题 2：技术冲突**
- **不合理设计**：
  ```
  - 同时使用 JPA 和 MyBatis 操作同一个数据库
  ```
- **问题**：两个 ORM 框架可能产生缓存冲突
- **扣分**：-10分
- **解决方案**：选择一个 ORM 框架

**问题 3：协议不兼容**
- **不合理设计**：
  ```
  - 前端使用 GraphQL
  - 后端只提供 REST API
  ```
- **问题**：前后端协议不匹配
- **扣分**：-10分
- **解决方案**：统一使用 REST 或 GraphQL

---

**3. 未考虑团队能力（-3分）**

**为什么要考虑团队能力**：
- 新技术需要学习时间
- 团队不熟悉的技术风险高
- 影响开发效率和质量

**应该考虑的因素**：

**团队技能**：
- 团队熟悉哪些技术？
- 团队的学习能力如何？
- 是否有技术专家？

**学习成本**：
- 新技术的学习曲线如何？
- 需要多长时间掌握？
- 是否有充足的学习资源？

**风险评估**：
- 使用新技术的风险有多大？
- 是否有备选方案？
- 是否可以通过培训降低风险？

**示例**：

**示例 1：团队不熟悉的技术**
- **场景**：团队只熟悉 Java Spring Boot
- **不合理设计**：使用 Go + gRPC
- **问题**：团队需要学习新语言和新框架
- **扣分**：-3分
- **合理设计**：使用 Java Spring Boot + REST

**示例 2：考虑团队能力的设计**
- **场景**：团队熟悉 Java，但不熟悉 Kubernetes
- **合理设计**：
  - 第一阶段：使用 Docker + Docker Compose 部署
  - 第二阶段：团队学习 Kubernetes 后迁移
- **优点**：降低风险，渐进式引入新技术

---

**检查要点**：
- [ ] 技术选型是否有充分的理由？
- [ ] 是否使用 ADR 记录重要决策？
- [ ] 技术栈之间是否兼容？
- [ ] 是否考虑了团队的技术能力和学习成本？
- [ ] 是否评估了技术方案的可行性和风险？

---

### 3. 设计一致性（20分）

设计一致性评估设计内部是否自洽，以及是否与需求保持一致。不一致的设计会导致实现困难和理解混乱。

#### 3.1 内部一致性（10分）

**评分项说明**：
- **设计内容存在冲突**：-5分/项
- **接口定义不一致**：-3分/项

**详细说明**：

**1. 设计内容存在冲突（-5分/项）**

**什么是设计冲突**：
- 设计的不同部分相互矛盾
- 数据流和控制流不一致
- 设计决策相互冲突

**常见冲突类型**：

**类型 1：数据模型冲突**
- **冲突设计**：
  ```
  - 架构设计：用户和订单是一对多关系
  - 数据模型：订单表没有 user_id 字段
  ```
- **问题**：架构设计与数据模型不一致
- **扣分**：-5分

**类型 2：接口设计冲突**
- **冲突设计**：
  ```
  - API 设计：POST /api/users 创建用户，返回用户 ID
  - 序列图：创建用户接口返回完整的用户对象
  ```
- **问题**：API 设计与序列图不一致
- **扣分**：-5分

**类型 3：状态转换冲突**
- **冲突设计**：
  ```
  - 状态机设计：订单从"待支付"只能转到"已支付"或"已取消"
  - 业务流程：订单可以从"待支付"直接转到"已完成"
  ```
- **问题**：状态机与业务流程不一致
- **扣分**：-5分

**类型 4：技术决策冲突**
- **冲突设计**：
  ```
  - ADR-001：选择 MySQL 作为主数据库
  - 数据模型设计：使用 MongoDB 的文档结构
  ```
- **问题**：技术选型与数据模型设计不一致
- **扣分**：-5分

---

**2. 接口定义不一致（-3分/项）**

**什么是接口定义不一致**：
- 同类接口的命名风格不统一
- 请求/响应格式不统一
- 错误处理方式不统一

**常见不一致类型**：

**类型 1：命名风格不一致**
- **不一致设计**：
  ```
  - GET /api/users          # 复数
  - GET /api/order/{id}     # 单数
  - GET /api/project-list   # 中划线
  ```
- **问题**：命名风格不统一
- **扣分**：-3分
- **一致设计**：
  ```
  - GET /api/users
  - GET /api/orders/{id}
  - GET /api/projects
  ```

**类型 2：响应格式不一致**
- **不一致设计**：
  ```
  - GET /api/users 返回：{code, message, data}
  - GET /api/orders 返回：{success, msg, result}
  ```
- **问题**：响应格式不统一
- **扣分**：-3分
- **一致设计**：所有接口使用统一的响应格式

**类型 3：分页参数不一致**
- **不一致设计**：
  ```
  - GET /api/users?page=1&size=10
  - GET /api/orders?pageNum=1&pageSize=10
  ```
- **问题**：分页参数名称不一致
- **扣分**：-3分
- **一致设计**：统一使用 page 和 size

**类型 4：错误码不一致**
- **不一致设计**：
  ```
  - 用户模块：1001-1999
  - 订单模块：2001-2999
  - 支付模块：1-100
  ```
- **问题**：错误码规则不一致
- **扣分**：-3分
- **一致设计**：统一错误码规则（如 1xxx 业务错误，2xxx 系统错误）

---

**检查要点**：
- [ ] 设计内容内部是否有矛盾？
- [ ] 模块间接口定义是否一致？
- [ ] 数据流和控制流是否合理？
- [ ] 命名和术语使用是否统一？
- [ ] 响应格式和错误处理是否统一？

---

#### 3.2 与需求一致性（10分）

**评分项说明**：
- **偏离需求意图**：-5分/项
- **过度设计**：-3分/项

**详细说明**：

**1. 偏离需求意图（-5分/项）**

**什么是偏离需求意图**：
- 设计的功能与需求不一致
- 设计改变了需求的核心目标
- 设计遗漏了需求的关键约束

**常见偏离类型**：

**类型 1：改变业务规则**
- **需求**：订单金额超过 1000 元需要审批
- **设计**：所有订单都需要审批
- **问题**：改变了业务规则
- **扣分**：-5分

**类型 2：改变数据范围**
- **需求**：用户只能查看自己创建的项目
- **设计**：用户可以查看所有项目，通过权限控制访问
- **问题**：改变了数据范围的设计思路
- **扣分**：-5分

**类型 3：改变性能要求**
- **需求**：API 响应时间 < 200ms
- **设计**：使用同步调用第三方服务（响应时间 > 500ms）
- **问题**：设计无法满足性能要求
- **扣分**：-5分

---

**2. 过度设计（-3分/项）**

**什么是过度设计**：
- 设计了需求未要求的复杂功能
- 提前设计了未来可能需要的功能
- 增加了不必要的抽象层次

**常见过度设计类型**：

**类型 1：过度抽象**
- **需求**：支持 MySQL 数据库
- **过度设计**：
  ```
  - 设计了数据库抽象层，支持 MySQL、PostgreSQL、Oracle
  - 设计了数据源切换机制
  - 设计了多数据源事务管理
  ```
- **问题**：需求只要求 MySQL，不需要支持多数据库
- **扣分**：-3分

**类型 2：过度扩展**
- **需求**：用户可以上传文件
- **过度设计**：
  ```
  - 设计了文件版本管理系统
  - 设计了文件协作编辑功能
  - 设计了文件权限管理系统
  ```
- **问题**：需求只要求基本的文件上传
- **扣分**：-3分/项

**类型 3：过度优化**
- **需求**：支持 100 个并发用户
- **过度设计**：
  ```
  - 设计了分布式缓存集群
  - 设计了读写分离
  - 设计了分库分表
  ```
- **问题**：100 个并发用户不需要这些复杂的优化
- **扣分**：-3分/项

**如何判断是否过度设计**：
1. **必要性检查**：这个设计是否是满足需求的必要条件？
2. **YAGNI 原则**：You Aren't Gonna Need It - 不要设计当前不需要的功能
3. **成本收益分析**：设计的复杂度是否与收益匹配？

---

**检查要点**：
- [ ] 设计是否准确理解了需求意图？
- [ ] 是否存在需求未提及的过度设计？
- [ ] 设计复杂度是否与需求匹配？
- [ ] 是否遵循 YAGNI 原则？

---

### 4. 可实施性（15分）

可实施性评估设计是否可以被实现，是否识别了技术难点和风险。不可实施的设计会导致开发受阻。

#### 4.1 实现路径清晰度（8分）

**评分项说明**：
- **缺少关键实现路径**：-4分/项
- **技术难点未识别**：-2分/项

**详细说明**：

**1. 缺少关键实现路径（-4分/项）**

**什么是实现路径**：
- 从设计到实现的具体步骤
- 关键技术点的实现方案
- 模块间的集成方案

**应该包含的实现路径**：

**示例 1：文件上传功能**
- **设计**：用户可以上传文件到 S3
- **应包含的实现路径**：
  1. 前端使用 multipart/form-data 上传文件
  2. 后端接收文件，校验文件大小和格式
  3. 生成唯一文件名（UUID + 原始扩展名）
  4. 使用 AWS SDK 上传到 S3
  5. 返回文件 URL 给前端
- **如果缺少**：-4分

**示例 2：分布式事务**
- **设计**：订单和库存需要保证一致性
- **应包含的实现路径**：
  1. 使用 Seata 实现分布式事务
  2. 配置 Seata Server
  3. 在订单服务和库存服务中集成 Seata Client
  4. 使用 @GlobalTransactional 注解标记事务
- **如果缺少**：-4分

---

**2. 技术难点未识别（-2分/项）**

**什么是技术难点**：
- 实现过程中可能遇到的技术挑战
- 需要特殊处理的技术点
- 可能影响进度的技术风险

**常见技术难点**：

**难点 1：性能优化**
- **场景**：需要支持 10000 QPS
- **技术难点**：
  - 数据库查询优化（索引、查询语句）
  - 缓存策略（缓存什么、何时失效）
  - 连接池配置（大小、超时时间）
- **如果未识别**：-2分

**难点 2：数据一致性**
- **场景**：分布式系统中的数据一致性
- **技术难点**：
  - 如何保证最终一致性
  - 如何处理并发冲突
  - 如何实现幂等性
- **如果未识别**：-2分

**难点 3：第三方集成**
- **场景**：集成第三方支付系统
- **技术难点**：
  - 如何处理支付回调
  - 如何处理网络超时
  - 如何保证支付幂等性
- **如果未识别**：-2分

---

**检查要点**：
- [ ] 是否提供了清晰的实现路径？
- [ ] 是否识别了关键的技术难点？
- [ ] 是否有明确的实现指导？
- [ ] 是否考虑了实现的可行性？

---

#### 4.2 风险识别（7分）

**评分项说明**：
- **未识别关键风险**：-3分/项
- **缺少应对策略**：-2分/项

**详细说明**：

**1. 未识别关键风险（-3分/项）**

**什么是技术风险**：
- 可能导致项目失败或延期的技术问题
- 不确定性高的技术点
- 依赖外部因素的技术点

**常见技术风险**：

**风险 1：性能风险**
- **场景**：设计了复杂的查询逻辑
- **风险**：查询性能可能无法满足要求
- **如果未识别**：-3分
- **应对策略**：
  - 进行性能测试验证
  - 准备优化方案（索引、缓存）
  - 准备降级方案

**风险 2：第三方依赖风险**
- **场景**：依赖第三方 API
- **风险**：第三方 API 可能不稳定或变更
- **如果未识别**：-3分
- **应对策略**：
  - 设计重试机制
  - 设计降级方案
  - 监控第三方 API 可用性

**风险 3：数据迁移风险**
- **场景**：需要从旧系统迁移数据
- **风险**：数据格式不兼容、数据量大
- **如果未识别**：-3分
- **应对策略**：
  - 设计数据转换方案
  - 分批迁移
  - 准备回滚方案

---

**2. 缺少应对策略（-2分/项）**

**什么是应对策略**：
- 针对识别的风险制定的应对方案
- 降低风险发生概率或影响的措施
- 风险发生后的补救措施

**应对策略类型**：

**策略 1：规避风险**
- **风险**：新技术不成熟
- **策略**：使用成熟的技术替代

**策略 2：降低风险**
- **风险**：性能可能不满足要求
- **策略**：
  - 提前进行性能测试
  - 准备多种优化方案
  - 设计性能监控

**策略 3：转移风险**
- **风险**：第三方服务不稳定
- **策略**：
  - 使用多个第三方服务提供商
  - 设计服务降级机制

**策略 4：接受风险**
- **风险**：某个功能可能延期
- **策略**：
  - 降低该功能的优先级
  - 准备备选方案

---

**检查要点**：
- [ ] 是否识别了潜在的技术风险？
- [ ] 是否制定了风险应对策略？
- [ ] 是否有备选方案？
- [ ] 是否考虑了外部依赖的风险？

---

### 5. 文档质量（10分）

#### 5.1 ADR 记录（5分）
- **缺少关键决策记录**：-2分/项
- **ADR 缺乏理由说明**：-1分/项

**检查要点**：
- [ ] 是否记录了重要的架构决策？
- [ ] ADR 是否包含背景、决策、理由、后果？
- [ ] 决策理由是否充分？

#### 5.2 设计文档完整性（5分）
- **缺少架构图**：-2分
- **缺少接口定义**：-2分
- **缺少数据模型**：-1分

**检查要点**：
- [ ] 是否包含系统架构图？
- [ ] 是否定义了核心接口？
- [ ] 是否设计了数据模型？
- [ ] 是否描述了关键流程？

---

## 评分标准

| 分数区间 | 评级 | 说明 |
|---------|------|------|
| 90-100 | 优秀 | 可直接进入下一阶段 |
| 80-89 | 良好 | 可进入下一阶段，但需记录改进点 |
| 70-79 | 合格 | 需针对性改进扣分项后进入下一阶段 |
| 60-69 | 需改进 | 必须改进后重新评分 |
| <60 | 不合格 | 必须重做该阶段 |

---

## 评分表模板

```markdown
## 技术设计阶段评分表

**项目名称**：[项目名称]
**评分日期**：YYYY-MM-DD
**评分人**：[评分人姓名]

| 维度 | 满分 | 扣分项 | 扣分 | 得分 |
|------|------|--------|------|------|
| **1. 需求覆盖度** | **25** | | | |
| 1.1 功能覆盖 | 15 | | | |
| 1.2 非功能性需求覆盖 | 10 | | | |
| **2. 设计合理性** | **30** | | | |
| 2.1 架构设计 | 15 | | | |
| 2.2 技术选型 | 15 | | | |
| **3. 设计一致性** | **20** | | | |
| 3.1 内部一致性 | 10 | | | |
| 3.2 与需求一致性 | 10 | | | |
| **4. 可实施性** | **15** | | | |
| 4.1 实现路径清晰度 | 8 | | | |
| 4.2 风险识别 | 7 | | | |
| **5. 文档质量** | **10** | | | |
| 5.1 ADR 记录 | 5 | | | |
| 5.2 设计文档完整性 | 5 | | | |
| **总分** | **100** | | | **XX** |

**评级**：[优秀/良好/合格/需改进/不合格]

### 主要问题
1. [问题描述]
2. [问题描述]
3. ...

### 改进建议
1. [改进建议]
2. [改进建议]
3. ...

### 是否可进入下一阶段
- [ ] 是
- [ ] 否

**备注**：[其他说明]
```

---

## 使用指南

### 评分流程

1. **准备阶段**
   - 确保设计文档已完成验证
   - 准备需求文档作为对照
   - 准备原始需求文档（如有）

2. **评分阶段**
   - 按照五个维度逐项检查
   - 记录发现的问题和扣分项
   - 计算各维度得分和总分

3. **反馈阶段**
   - 填写评分表
   - 列出主要问题和改进建议
   - 决定是否可进入下一阶段

4. **改进阶段**
   - 根据反馈进行改进
   - 重新评分验证

### 注意事项

- **对照需求**：始终以需求文档为基准进行评分
- **关注合理性**：不仅检查是否覆盖需求，还要评估设计的合理性
- **记录决策**：重要的架构决策必须有 ADR 记录
- **考虑可实施性**：设计必须是可以实现的，不能过于理想化

---

## 常见问题

### Q1：如何判断架构选型是否合理？
**A**：考虑以下因素：
- 是否符合项目规模和复杂度
- 是否符合团队技术能力
- 是否满足性能和可扩展性要求
- 是否考虑了成本和时间约束

### Q2：什么情况下算"过度设计"？
**A**：设计了需求中未提及的功能，且这些功能不是必要的技术支撑。例如：
- 为简单的单体应用设计微服务架构
- 为小规模数据设计复杂的分库分表方案
- 提前实现未来可能需要的扩展点

### Q3：ADR 必须记录所有决策吗？
**A**：不需要。只记录重要的架构决策，如：
- 架构模式选择（分层、微服务等）
- 关键技术选型（数据库、框架等）
- 重要的设计权衡（性能 vs 可维护性等）

### Q4：设计文档应该包含多少实现细节？
**A**：设计应该描述"做什么"和"为什么"，而非"怎么做"。包含：
- 架构和模块划分
- 接口定义和数据模型
- 关键流程和算法思路
- 不包含具体的代码实现

### Q5：如何评估技术方案的可行性？
**A**：可以通过以下方式：
- 技术调研和原型验证
- 参考类似项目的经验
- 评估团队的技术能力
- 识别潜在的技术风险

---

## 设计质量检查清单

在评分前，可以使用以下检查清单进行自检：

### 需求覆盖
- [ ] 所有功能需求都有对应的设计方案
- [ ] 所有非功能性需求都有对应的设计方案
- [ ] 没有遗漏的需求点

### 架构设计
- [ ] 架构选型有充分的理由
- [ ] 模块划分清晰，职责明确
- [ ] 依赖关系合理，无循环依赖
- [ ] 符合 DDD 分层架构原则（如适用）

### 技术选型
- [ ] 技术选型有 ADR 记录
- [ ] 技术栈之间兼容
- [ ] 考虑了团队能力和学习成本
- [ ] 评估了技术风险

### 设计一致性
- [ ] 设计内容内部无冲突
- [ ] 接口定义一致
- [ ] 与需求文档一致
- [ ] 无过度设计

### 可实施性
- [ ] 提供了清晰的实现路径
- [ ] 识别了技术难点
- [ ] 识别了潜在风险
- [ ] 制定了应对策略

### 文档质量
- [ ] 包含系统架构图
- [ ] 定义了核心接口
- [ ] 设计了数据模型
- [ ] 记录了重要的 ADR

---



---

## 文档质量详细说明

### 5.1 ADR 记录详细说明

#### 缺少关键决策记录（-2分/项）

**必须记录的关键决策类型**：
1. **架构模式选择**：单体 vs 微服务 vs 模块化单体
2. **数据库选择**：MySQL vs PostgreSQL vs MongoDB
3. **缓存方案选择**：Redis vs Memcached vs 本地缓存
4. **消息队列选择**：RabbitMQ vs Kafka vs RocketMQ
5. **重要的设计权衡**：性能 vs 可维护性 vs 成本

#### ADR 缺乏理由说明（-1分/项）

**完整的 ADR 必需元素**：
1. **标题**：简短描述决策内容
2. **状态**：提议中、已接受、已废弃、已替代
3. **背景**：为什么需要做这个决策？
4. **决策**：具体的决策内容
5. **理由**：为什么选择这个方案？
6. **后果**：决策带来的影响（正面和负面）

**可选但推荐的元素**：
7. **备选方案**：考虑过哪些其他方案？
8. **相关决策**：与哪些其他 ADR 相关？

---

### 5.2 设计文档完整性详细说明

#### 缺少架构图（-2分）

**必需的架构图类型**：
1. **系统架构图**：展示系统的主要组件和交互关系
2. **模块架构图**：展示系统内部的模块划分（如适用）
3. **部署架构图**：展示系统的部署结构（如适用）

#### 缺少接口定义（-2分）

**API 接口定义应包含**：
- 接口路径和方法
- 请求参数（类型、必填、说明）
- 响应格式（成功、失败）
- 错误码说明

**模块接口定义应包含**：
- 接口签名
- 参数说明
- 返回值说明
- 异常说明

#### 缺少数据模型（-1分）

**数据模型应包含**：
- 实体关系图（ER 图）
- 数据表设计（表名、字段、类型、约束）
- 索引设计
- 关键字段说明

---

**版本**：v1.1
**最后更新**：2025-01-18
